num = 10
#? ~ это тоже самое что NOT:
# ~0 -> 1
# ~1 -> 0
print("Not: ")
print(~num)
print(~15)
print(~-8)
print()

#? & это тоже самое что AND:
# применяется для выключение переменных
# 0 & 0 -> 0
# 1 & 0 -> 0
# 0 & 1 -> 0
# 1 & 1 -> 1
print("And:")
print(f"{0b111000 & 0b000111 = }")
print(f"{10 % 99 = }")
flags = 100
mask = 4
if flags & mask == mask:
    print(f"2-й бит числа {flags} включен")
else:
    print(f"2-й бит числа {flags} выключен")
flags = 13
mask = 5
flags = flags & ~mask
print(f"0 и 2 биты числа ({flags = }) выключены")
print()

#? | это тоже самое что OR:
# применяется для включение переменных
# 0 | 0 -> 0
# 1 | 0 -> 1
# 0 | 1 -> 1
# 1 | 1 -> 1
print(f"{bin(0b00101 | 0b11001) = }")
flags = 8
mask = 5
res = flags | mask
print(f"0 и 2 биты числа {flags} включены. Результат: {res}")
print()

#? ^ это тоже самое что XOR:
# используется дле переключения битов
# 0 ^ 0 -> 0
# 1 ^ 0 -> 1
# 0 ^ 1 -> 1
# 1 ^ 1 -> 0
print(f"{bin(0b010111 ^ 0b001011) = }")
flags = 9
mask = 1
res = flags ^ mask
print(f"У числа {flags} 0-й бит был переключен. Результат: {res}")
flags = res ^ mask
print(f"У числа {res} 0-й бит был переключен. Результат: {flags}")
print()

#? >> смещение бит вправо
# грубо говоря целочисленно делит число на [2**n], где n -- это длинна на которую сдвигается число
x = 160
print(f"{bin(160) = }")
print(f"{160 >> 1 = }")
print(f"{bin(80) = }")
print()

#? << смещение бит вправо
# грубо говоря умножает число на [2**n], где n -- это длинна на которую сдвигается число
print(f"{bin(160)        = }")
print(f"{160 << 1 = }    ({bin(160 << 1)})")
print(f"{160 << 2 = }    ({bin(160 << 2)})")
print(f"{160 << 3 = }   ({bin(160 << 3)})")
print()